# Graphql
simple graphql implementation with query, mutation and suscription.

## Links of interest

* [graphql client(chrome extension)](https://altair.sirmuel.design/)
* [spring boot dependencies](https://github.com/graphql-java-kickstart/graphql-spring-boot)
* [graphql documentation](https://graphql.org/)
* [apollo client](https://www.apollographql.com/docs/) 


## About graphQL

Traditional REST APIs work with the concept of Resources that the server manages. These resources can be manipulated in some standard ways, following the various HTTP verbs. This works very well as long as our API fits the resource concept, but quickly falls apart when we need to deviate from it.

This also suffers when the client needs data from multiple resources at the same time. For example, requesting a blog post and the comments. Typically this is solved by either having the client make multiple requests or by having the server supply extra data that might not always be required, leading to larger response sizes.

GraphQL offers a solution to both of these problems. It allows for the client to specify exactly what data is desired, including from navigating child resources in a single request, and allows for multiple queries in a single request.

GraphQL allows client applications to define what data they need exactly, nothing more, nothing less.

Unlike REST, GraphQL server operates on a single URL/endpoint, usually /graphql, and all GraphQL requests for a given service should be directed at this endpoint. Generally, the GraphQL request is sent through an HTTP POST request, where the contents for GraphQL request are placed in the body of the POST request

While you have POST, GET, PUT, and others as request methods in a REST API, for GraphQL, you have just Query (equivalent of GET in REST) and Mutation (equivalent of PUT, POST, PATCH and DELETE in REST).

It’s often useful to ask a GraphQL schema for information about what queries it supports. GraphQL allows us to do so using the introspection system. Through this one can access the documentation about the type system in the schema which could be used for rich IDE experiences, providing better development workflows while using graphQL. 
* **Schema**: Contract between the client and the server. Anything the client tries to do with the server that is outside the schema will not work. Contains what information is being made available. A client could use this schema and determine how to construct a request, which will fetch/update the relevant data on the server. 
* **type**: The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service, and what fields it has.

There are two different types of GraphQL requests:
* **query**: Used for reading data from the server. By Convention “query” requests should have no side-effects on the server.
* **mutation**: Used to modify the data on the server side. Just like in queries, if the mutation field returns an object type, one could ask for nested fields. This can be useful for fetching the new state of an object after an update.
* **subscription**: Defines a mechanism for real-time push-style updates.

Both could have:
* **arguments**: Can be built by scalar types (String, Int, Float, Boolean, UUID) as well by complex objects (the fields of which are either other objects or scalar types). When arguments are present server could use these arguments, either to identify a resource or filter the response.
* **variables**: In a real application the arguments to a request will be dynamic, generated by user actions. It wouldn’t be a good idea to pass these dynamic arguments directly as part of the query. These values are called variables. Variables are passed alongside the request, which contains placeholders instead of actual argument values. On the server, all placeholders in the request will be resolved from the variables before executing the request.
* **tags**: We can assign names to each query/mutation
* **aliases** : We can use alias as part of internal queries or mutations, chaining a set of them as part of the same request. This allows us to reuse arguments sent to the query/mutation. 

## Generated schema

http://localhost:8080/graphql/schema.json

## How to test it!
We can choose over the following options:
1. importing the file `graph_q_l_collection.agc` to graphql chrome extension mentioned at the top.
2. using the [embedded client](http://localhost:8080/graphiql) execute the following mutations and queries: 

* add a new snack
```shell script
mutation {
  newSnack(name: "French Fries", amount: 40.5) {
    id
    name
    amount
  }
}
```
* add a couple of reviews
```shell script
mutation {
    newReview(snackId:"SNACK_ID",
    text: "Awesome snack!", rating:5
    ){
        snackId, text, rating
    }
}
```
* query it
```shell script
query {
  snacks {
    name,
    reviews {
      text, rating
    }
  }
}
```
